package us.etsii.fvt.services;

import java.util.ArrayList;
import java.util.Collections;
import java.util.List;

import org.apache.logging.log4j.LogManager;
import org.apache.logging.log4j.Logger;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.data.domain.Page;
import org.springframework.data.domain.PageImpl;
import org.springframework.data.domain.PageRequest;
import org.springframework.data.domain.Pageable;
import org.springframework.data.domain.Sort;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;

import us.etsii.fvt.domains.Vulnerability;
import us.etsii.fvt.repositories.VulnerabilityRepository;
import us.etsii.fvt.utils.I18n;
import us.etsii.fvt.utils.constants.CommonsResources;
import us.etsii.fvt.utils.constants.LanguageKeys;
import us.etsii.fvt.utils.constants.Parameters;

/**
 * @author Javier Villalba Ramírez. Free Vulnerabilities Tracker, 2019
 * 
 *         This class represents the vulnerability service.
 */
@Service
@Transactional
public class VulnerabilityService {

    /**
     * vulnerability repository attribute.
     */
    @Autowired
    private VulnerabilityRepository vulnerabilityRepository;

    /**
     * Vulnerabilities list loaded from database after each CVE refresh.
     */
    private List<Vulnerability> vuls = new ArrayList<Vulnerability>();

    /**
     * Logger constant used to write in the log of the application.
     */
    private static final Logger LOGGER = LogManager.getLogger(VulnerabilityService.class);

    /**
     * Method that saves a vulnerability into database.
     * 
     * @param vulnerability Object to save.
     */
    public void saveVulnerability(Vulnerability vulnerability) {
	try {
	    LOGGER.debug(I18n.getResource(LanguageKeys.LogsMessages.LOG_SERVICE_SAVE_VULNERABILITY, true));
	    if (vulnerability != null) {
		vulnerabilityRepository.save(vulnerability);
		LOGGER.debug(I18n.getResource(LanguageKeys.LogsMessages.LOG_SERVICE_VULNERABILITY_SAVED, true,
			new Object[] { vulnerability.getId() }));
	    } else {
		LOGGER.error(I18n.getResource(LanguageKeys.LogsMessages.LOG_ERROR_VULNERABILITY_NULL, true));
	    }
	} catch (Exception e) {
	    LOGGER.error(I18n.getResource(LanguageKeys.LogsMessages.UNEXPECTED_ERROR, true, new Object[] { e }));
	}
    }

    /**
     * Method that store a vulnerabilities list into database.
     * 
     * @param vuls Vulnerabilities list to store.
     */
    public void saveAll(List<Vulnerability> vuls) {
	try {
	    // Si la lista a guardar no es nula, la recorremos y vamos guardado una a una.
	    if (vuls != null) {
		LOGGER.debug(I18n.getResource(LanguageKeys.LogsMessages.LOG_VULS_LIST_SAVE, true,
			new Object[] { vuls.size() }));
		for (Vulnerability vul : vuls) {
		    saveVulnerability(vul);
		}
	    } else {
		LOGGER.error(I18n.getResource(LanguageKeys.LogsMessages.LOG_ERROR_VULS_LIST_NULL, true));
	    }
	} catch (Exception e) {
	    LOGGER.error(I18n.getResource(LanguageKeys.LogsMessages.UNEXPECTED_ERROR, true, new Object[] { e }));
	}
    }

    /**
     * Method that get the last stored vulnerability from database.
     * 
     * @return the last stored vulnerability if it exists or null in other case.
     */
    public Vulnerability findLastVulnerabilityStored() {
	try {
	    // Construimos la petición
	    LOGGER.debug(I18n.getResource(LanguageKeys.LogsMessages.LOG_FIND_LAST_VUL_STORED, true));
	    PageRequest request = PageRequest.of(0, 1, Sort.by(Sort.Direction.DESC, Parameters.SEQ));

	    // Si la petición se ha construido correctamente, realizamos la petición a base
	    // de datos.
	    if (request != null) {
		try {
		    Vulnerability vul = vulnerabilityRepository.findLastVulnerability(request).getContent().get(0);
		    LOGGER.debug(I18n.getResource(LanguageKeys.LogsMessages.LOG_LAST_VUL_FOUND, true,
			    new Object[] { vul.getSeq() }));
		    return vul;
		} catch (IndexOutOfBoundsException e) {
		    LOGGER.warn(I18n.getResource(LanguageKeys.LogsMessages.LOG_LAST_VUL_NOT_FOUND, true));
		}
	    }
	    return null;
	} catch (Exception e) {
	    LOGGER.error(I18n.getResource(LanguageKeys.LogsMessages.UNEXPECTED_ERROR, true, new Object[] { e }));
	    return null;
	}
    }

    /**
     * Method that gets a set of vulnerabilities according to the page requested.
     * 
     * @param pageable Parameter that indicates the page requested.
     * @return a new page of the vulnerabilities list.
     */
    public Page<Vulnerability> findAllVulsPaginated(Pageable pageable) {
	try {
	    // Recuperamos los parámetros de paginación.
	    int pageSize = pageable.getPageSize();
	    int currentPage = pageable.getPageNumber();
	    int startItem = currentPage * pageSize;

	    // iniciamos la lista que contendrá la sublista de vulnerabilidades a mostrar.
	    List<Vulnerability> vulsPageList;

	    // Si el número de vulnerabilidades es menor al número solicitado, devolvemos la
	    // lista vacía, sino, devolvemos las vulnerabilidades disponibles hasta
	    // completar el número solicitado.
	    if (vuls.size() < startItem) {
		vulsPageList = Collections.emptyList();
	    } else {
		int toIndex = Math.min(startItem + pageSize, vuls.size());
		vulsPageList = vuls.subList(startItem, toIndex);
	    }

	    // Recuperamos la página a mostrar y la devolvemos.
	    Page<Vulnerability> vulsPage = new PageImpl<Vulnerability>(vulsPageList,
		    PageRequest.of(currentPage, pageSize), vuls.size());
	    LOGGER.debug(I18n.getResource(LanguageKeys.LogsMessages.LOG_SERVICE_VULS_ALL_FOUND, true,
		    new Object[] { vulsPage.getNumberOfElements(), vulsPage.getTotalElements() }));
	    return vulsPage;

	} catch (Exception e) {
	    LOGGER.error(I18n.getResource(LanguageKeys.LogsMessages.UNEXPECTED_ERROR, true, new Object[] { e }));
	    return null;
	}
    }

    /**
     * Method that gets a set of vulnerabilities which match with filters.
     * 
     * @param pageable Parameter that indicates the page requested.
     * @param search   String that represents the set of characters to match with
     *                 the vulnerabilities names.
     * @param year     String that represents the year to match with the
     *                 vulnerabilities years.
     * @return a set of vulnerabilities which match with the given filter or null in
     *         error case.
     */
    public Page<Vulnerability> findAllVulsPaginatedWithFilter(PageRequest pageable, String search, String year) {
	try {
	    // Recuperamos los parámetros de paginación.
	    int pageSize = pageable.getPageSize();
	    int currentPage = pageable.getPageNumber();
	    int startItem = currentPage * pageSize;

	    // iniciamos la lista que contendrá la sublista de vulnerabilidades a mostrar.
	    List<Vulnerability> vulsPageList;

	    // Aplicamos el filtro a la lista de vulnerabilidades.
	    List<Vulnerability> vulsFiltered = new ArrayList<Vulnerability>();
	    // Si el filtro correspondiente al año es válido y es un número, recuperamos
	    // todas aquellas vulnerabilidades cuyo año (incluido en el nombre) coincida con
	    // el filtro. El nombre de la vulnerabilidad debe seguir el patrón
	    // 'CVE-yyyy-nnnn'.
	    if (year != null && !year.trim().isEmpty() && year.matches(CommonsResources.ONLY_NUMBER_PATTERN)) {
		for (Vulnerability vul : vuls) {
		    if (vul.getName().split(CommonsResources.HYPHEN)[1].equals(year)) {
			vulsFiltered.add(vul);
		    }
		}
	    } else {
		// Si el año no es un número o no es válido, añadimos la lista completa de
		// vulnerabilidades a la lista filtrada.
		vulsFiltered = new ArrayList<Vulnerability>(vuls);
	    }

	    // Si el filtro de búsqueda por nombre es válido, recorremos la lista filtrada y
	    // descartamos aquellos elementos que no coincidan con el filtro.
	    if (search != null && !search.trim().isEmpty()) {
		List<Vulnerability> vulsFilteredClone = new ArrayList<Vulnerability>();
		for (Vulnerability vul : vulsFiltered) {
		    if (vul.getName().contains(search.trim())) {
			vulsFilteredClone.add(vul);
		    }
		}
		vulsFiltered = vulsFilteredClone;
	    }

	    // Si el número de vulnerabilidades es menor al número solicitado, devolvemos la
	    // lista vacía, sino, devolvemos las vulnerabilidades disponibles hasta
	    // completar el número solicitado.
	    if (vulsFiltered.size() < startItem) {
		vulsPageList = Collections.emptyList();
	    } else {
		int toIndex = Math.min(startItem + pageSize, vulsFiltered.size());
		vulsPageList = vulsFiltered.subList(startItem, toIndex);
	    }

	    // Recuperamos la página a mostrar y la devolvemos.
	    Page<Vulnerability> vulsPage = new PageImpl<Vulnerability>(vulsPageList,
		    PageRequest.of(currentPage, pageSize), vulsFiltered.size());
	    LOGGER.debug(I18n.getResource(LanguageKeys.LogsMessages.LOG_SERVICE_VULS_ALL_FOUND, true,
		    new Object[] { vulsPage.getNumberOfElements(), vulsPage.getTotalElements() }));
	    return vulsPage;
	} catch (Exception e) {
	    LOGGER.error(I18n.getResource(LanguageKeys.LogsMessages.UNEXPECTED_ERROR, true, new Object[] { e }));
	    return null;
	}
    }

    /**
     * Method that updates the vulnerabilities list attribute of the service.
     */
    public void refreshAllVuls() {
	vuls = vulnerabilityRepository.findAll();
    }

    /**
     * Method that gets all stored vulnerabilities.
     * 
     * @return a list with all vulnerabilities stored.
     */
    public List<Vulnerability> getAllVuls() {
	return vuls;
    }

}
