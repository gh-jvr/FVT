package us.etsii.fvt.controllers;

import java.util.ArrayList;
import java.util.List;
import java.util.Optional;

import org.apache.commons.lang.NullArgumentException;
import org.apache.logging.log4j.LogManager;
import org.apache.logging.log4j.Logger;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.data.domain.Page;
import org.springframework.data.domain.PageRequest;
import org.springframework.security.core.Authentication;
import org.springframework.security.core.context.SecurityContextHolder;
import org.springframework.stereotype.Controller;
import org.springframework.web.bind.annotation.PostMapping;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RequestMethod;
import org.springframework.web.bind.annotation.RequestParam;
import org.springframework.web.servlet.ModelAndView;

import us.etsii.fvt.domains.User;
import us.etsii.fvt.domains.Vulnerability;
import us.etsii.fvt.services.NotificationService;
import us.etsii.fvt.services.UserService;
import us.etsii.fvt.services.VulnerabilityService;
import us.etsii.fvt.utils.CveUtils;
import us.etsii.fvt.utils.I18n;
import us.etsii.fvt.utils.Parsers;
import us.etsii.fvt.utils.constants.CommonsResources;
import us.etsii.fvt.utils.constants.LanguageKeys;
import us.etsii.fvt.utils.constants.Parameters;
import us.etsii.fvt.utils.constants.PathResources;
import us.etsii.fvt.utils.types.SearchVulForm;

/**
 * 
 * @author Javier Villalba Ramírez. Free Vulnerabilities Tracker, 2019
 * 
 *         This class represents the vulnerabilities controller.
 */
@Controller
public class VulnerabilityController {

    /**
     * Logger constant used to write in the log of the application.
     */
    private static final Logger LOGGER = LogManager.getLogger(VulnerabilityController.class);

    /**
     * Constant that defines the minimum current page number.
     */
    private static final Integer MIN_CURRENT_PAGE = 1;

    /**
     * Constant that defines the minimum page size number.
     */
    private static final Integer MIN_PAGE_SIZE = 1;

    /**
     * Constant that defines the maximum page size number.
     */
    private static final Integer MAX_PAGE_SIZE = 5000;

    /**
     * Constant that defines the default page size number.
     */
    private static final Integer DEFAULT_PAGE_SIZE = 50;

    /**
     * CVE utilities class instance.
     */
    private CveUtils cveUtils = new CveUtils();

    /**
     * User service attribute.
     */
    @Autowired
    private UserService userService;

    /**
     * Vulnerability service attribute.
     */
    @Autowired
    private VulnerabilityService vulnerabilityService;

    /**
     * Notification service attribute.
     */
    @Autowired
    private NotificationService notificationService;

    /**
     * Attribute that represent the last search filter form stored.
     */
    private SearchVulForm lastSearchVulForm = null;

    /**
     * Method that maps the request for the resource '/vulnerability' through of a
     * get HTTP method.
     * 
     * @param page current page to show.
     * @param size Number of element to show by page.
     * @return a new view with the vulnerability list.
     */
    @RequestMapping(value = { CommonsResources.SLASH + PathResources.VULNERABILITY }, method = RequestMethod.GET)
    public ModelAndView vulnerability(@RequestParam(Parameters.PAGE) Optional<Integer> page,
	    @RequestParam(Parameters.SIZE) Optional<Integer> size) {
	try {
	    ModelAndView modelAndView = new ModelAndView();

	    // Recuperamos el usuario.
	    Authentication auth = SecurityContextHolder.getContext().getAuthentication();
	    if (auth != null) {
		User user = userService.findUserByEmail(auth.getName());

		// Si el usuario no existe en base de datos, lanzamos una excepción
		if (user == null) {
		    throw new NullArgumentException(I18n.getResource(LanguageKeys.ERROR_USER_NOT_EXISTS, false));
		}
		LOGGER.debug(I18n.getResource(LanguageKeys.LogsMessages.LOG_RESOURCES_REQUEST, true,
			new Object[] { PathResources.VULNERABILITY, user.getId() }));

		// Comprobamos si existen notificaciones sin leer y añadimos el parámetro al
		// modelo.
		boolean thereAreNotifications = notificationService.userHasNotifications(user.getId());
		modelAndView.addObject(Parameters.THERE_ARE_NOTIFICATIONS, thereAreNotifications);

		// Recuperamos los parámetros de paginación (o los inicializamos).
		int currentPage = page.orElse(MIN_CURRENT_PAGE);
		if (currentPage < MIN_CURRENT_PAGE) {
		    currentPage = MIN_CURRENT_PAGE;
		}
		int pageSize = size.orElse(DEFAULT_PAGE_SIZE);
		if (pageSize < MIN_PAGE_SIZE) {
		    pageSize = MIN_PAGE_SIZE;
		} else if (pageSize > MAX_PAGE_SIZE) {
		    pageSize = MAX_PAGE_SIZE;
		}

		// Recuperamos los posibles años a mostrar.
		List<String> years = new ArrayList<String>();
		years.addAll(Parsers.parseListToString(cveUtils.getAllAvailableYear()));
		// Añadimos el valor por defecto.
		years.add(0, I18n.getResource(LanguageKeys.ALL, false));

		// Recuperamos la página de vulnerabilidades a mostrar.
		Page<Vulnerability> vulsPage = vulnerabilityService
			.findAllVulsPaginated(PageRequest.of(currentPage - 1, pageSize));

		// Añadimos la página al modelo.
		modelAndView.addObject(Parameters.VULS_PAGE, vulsPage);

		// Añadimos los años para filtrar los resultados.
		modelAndView.addObject(Parameters.YEARS, years);

		// Añadimos el usuario al modelo.
		modelAndView.addObject(Parameters.CURRENT_USER, user);
		modelAndView.addObject(Parameters.FULL_NAME, user.getFullname());

		// Añadimos el formulario de filtro vacío.
		SearchVulForm searchVulForm = new SearchVulForm();
		modelAndView.addObject(Parameters.SEARCH_VUL_FORM, searchVulForm);

		// Devolvemos el modelo.
		modelAndView.setViewName(PathResources.VULNERABILITY);
		return modelAndView;
	    } else {
		LOGGER.error(I18n.getResource(LanguageKeys.LogsMessages.LOG_ERROR_USER_NOT_ACCESSIBLE, true));
		throw new NullArgumentException(I18n.getResource(LanguageKeys.ERROR_USER_NOT_ACCESSIBLE, false));
	    }
	} catch (Exception e) {
	    LOGGER.error(I18n.getResource(LanguageKeys.LogsMessages.UNEXPECTED_ERROR, true, new Object[] { e }));
	    return new ModelAndView(PathResources.ERROR);
	}
    }

    /**
     * Method that maps the request for the resource '/vulnerability/search' through
     * of a post HTTP method and updates the attributes of the class.
     * 
     * @param searchVulForm Search vulnerability form type with the filter values.
     * @return a new redirected view with the filtered results.
     */
    @PostMapping(CommonsResources.SLASH + PathResources.VULNERABILITY + CommonsResources.SLASH + PathResources.SEARCH)
    public ModelAndView search(SearchVulForm searchVulForm) {
	try {

	    // Si no se han introducido filtros, se pone a null la variable encargada de
	    // guardar el último filtro insertado, sino, actualizamos la variable.
	    if (searchVulForm == null
		    || ((searchVulForm.getSearch() == null || searchVulForm.getSearch().trim().isEmpty())
			    && (searchVulForm.getYear() == null || searchVulForm.getYear().trim().isEmpty()))) {
		lastSearchVulForm = null;
	    } else {
		lastSearchVulForm = searchVulForm;
	    }

	    // Redireccionamos a la vista con los resultados del filtro.
	    return new ModelAndView(Parameters.REDIRECT + CommonsResources.COLON + CommonsResources.SLASH
		    + PathResources.VULNERABILITY + CommonsResources.SLASH + PathResources.SEARCH);
	} catch (Exception e) {
	    LOGGER.error(I18n.getResource(LanguageKeys.LogsMessages.UNEXPECTED_ERROR, true, new Object[] { e }));
	    return new ModelAndView(PathResources.ERROR);
	}
    }

    /**
     * Method that maps the request for the resource '/vulnerability/search' through
     * of a get HTTP method.
     * 
     * @param page current page to show.
     * @param size Number of element to show by page.
     * @return a new view with the filtered elements.
     */
    @RequestMapping(value = { CommonsResources.SLASH + PathResources.VULNERABILITY + CommonsResources.SLASH
	    + PathResources.SEARCH }, method = RequestMethod.GET)
    public ModelAndView searchNavegation(@RequestParam(Parameters.PAGE) Optional<Integer> page,
	    @RequestParam(Parameters.SIZE) Optional<Integer> size) {
	try {
	    ModelAndView modelAndView = new ModelAndView();

	    // Recuperamos el usuario.
	    Authentication auth = SecurityContextHolder.getContext().getAuthentication();
	    if (auth != null) {
		User user = userService.findUserByEmail(auth.getName());

		// Si el usuario no existe en base de datos, lanzamos una excepción.
		if (user == null) {
		    throw new NullArgumentException(I18n.getResource(LanguageKeys.ERROR_USER_NOT_EXISTS, false));
		}

		// Comprobamos si existen notificaciones sin leer y añadimos el parámetro al
		// modelo.
		boolean thereAreNotifications = notificationService.userHasNotifications(user.getId());
		modelAndView.addObject(Parameters.THERE_ARE_NOTIFICATIONS, thereAreNotifications);

		// Recuperamos los parámetros de paginación (o los inicializamos).
		int currentPage = page.orElse(MIN_CURRENT_PAGE);
		if (currentPage < MIN_CURRENT_PAGE) {
		    currentPage = MIN_CURRENT_PAGE;
		}
		int pageSize = size.orElse(DEFAULT_PAGE_SIZE);
		if (pageSize < MIN_PAGE_SIZE) {
		    pageSize = MIN_PAGE_SIZE;
		} else if (pageSize > MAX_PAGE_SIZE) {
		    pageSize = MAX_PAGE_SIZE;
		}

		// Recuperamos los posibles años a mostrar.
		List<String> years = new ArrayList<String>();
		years.addAll(Parsers.parseListToString(cveUtils.getAllAvailableYear()));
		// Añadimos el valor por defecto.
		years.add(0, I18n.getResource(LanguageKeys.ALL, false));

		// Si existe un filtro previamente almacenado, realizamos la búsqueda con
		// filtros, sino, realizamos una búsqueda normal de todos los elementos.
		Page<Vulnerability> vulsPage = null;
		if (lastSearchVulForm != null) {
		    vulsPage = vulnerabilityService.findAllVulsPaginatedWithFilter(
			    PageRequest.of(currentPage - 1, pageSize), lastSearchVulForm.getSearch(),
			    lastSearchVulForm.getYear());
		} else {
		    vulsPage = vulnerabilityService.findAllVulsPaginated(PageRequest.of(currentPage - 1, pageSize));
		}

		// Añadimos la página al modelo.
		modelAndView.addObject(Parameters.VULS_PAGE, vulsPage);

		// Añadimos los años para filtrar los resultados.
		modelAndView.addObject(Parameters.YEARS, years);

		// Añadimos el usuario al modelo.
		modelAndView.addObject(Parameters.CURRENT_USER, user);
		modelAndView.addObject(Parameters.FULL_NAME, user.getFullname());

		// Añadimos el formulario de filtro almacenado.
		modelAndView.addObject(Parameters.SEARCH_VUL_FORM, lastSearchVulForm);

		// Devolvemos el modelo.
		modelAndView.setViewName(PathResources.VULNERABILITY);
		return modelAndView;
	    } else {
		LOGGER.error(I18n.getResource(LanguageKeys.LogsMessages.LOG_ERROR_USER_NOT_ACCESSIBLE, true));
		throw new NullArgumentException(I18n.getResource(LanguageKeys.ERROR_USER_NOT_ACCESSIBLE, false));
	    }
	} catch (Exception e) {
	    LOGGER.error(I18n.getResource(LanguageKeys.LogsMessages.UNEXPECTED_ERROR, true, new Object[] { e }));
	    return new ModelAndView(PathResources.ERROR);
	}
    }

    /**
     * Method that maps the request for the resource '/vulnerability/search/clean'
     * through of a get HTTP method.
     * 
     * @return a redirected view with the list of vulnerability and the filter
     *         cleaned.
     */
    @RequestMapping(value = { CommonsResources.SLASH + PathResources.VULNERABILITY + CommonsResources.SLASH
	    + PathResources.SEARCH + CommonsResources.SLASH + PathResources.CLEAN }, method = RequestMethod.GET)
    public ModelAndView cleanFilters() {
	try {

	    // Reiniciamos el último filtro almacenado a su valor por defecto.
	    lastSearchVulForm = new SearchVulForm();

	    // Redireccionamos a la vista principal de todas las vulnerabilidades.
	    return new ModelAndView(Parameters.REDIRECT + CommonsResources.COLON + CommonsResources.SLASH
		    + PathResources.VULNERABILITY);
	} catch (Exception e) {
	    LOGGER.error(I18n.getResource(LanguageKeys.LogsMessages.UNEXPECTED_ERROR, true, new Object[] { e }));
	    return new ModelAndView(PathResources.ERROR);
	}
    }
}
